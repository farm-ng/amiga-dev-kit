"use strict";(self.webpackChunkamiga_developers_website=self.webpackChunkamiga_developers_website||[]).push([[1164],{85062:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var r=o(74848),s=o(28453);const t={id:"transforms-and-poses",title:"Transforms & Poses"},i=void 0,a={id:"concepts/transforms_and_poses/transforms-and-poses",title:"Transforms & Poses",description:"Fundamental Concepts",source:"@site/docs/concepts/transforms_and_poses/README.md",sourceDirName:"concepts/transforms_and_poses",slug:"/concepts/transforms_and_poses/",permalink:"/docs/concepts/transforms_and_poses/",draft:!1,unlisted:!1,editUrl:"https://github.com/farm-ng/amiga-dev-kit/tree/main/website/docs/concepts/transforms_and_poses/README.md",tags:[],version:"current",frontMatter:{id:"transforms-and-poses",title:"Transforms & Poses"},sidebar:"Developer",previous:{title:"Amiga Development 101",permalink:"/docs/concepts/system_overview/"},next:{title:"Tracks & Waypoints",permalink:"/docs/concepts/tracks_and_waypoints/"}},c={},d=[{value:"Fundamental Concepts",id:"fundamental-concepts",level:2},{value:"Frames of Reference",id:"frames-of-reference",level:3},{value:"Transformations",id:"transformations",level:3},{value:"Quaternions",id:"quaternions",level:4},{value:"Transform math",id:"transform-math",level:4},{value:"Poses",id:"poses",level:3},{value:"The farm-ng <code>Pose</code> proto",id:"the-farm-ng-pose-proto",level:3},{value:"Properties of Isometry3F64",id:"properties-of-isometry3f64",level:4},{value:"Resources",id:"resources",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"fundamental-concepts",children:"Fundamental Concepts"}),"\n",(0,r.jsx)(n.p,{children:"Before we can create autonomy applications for our robot,\nwe need to understand where our robot and other points of reference are.\nThe following concepts are critical to understand if you wish\nto develop autonomous robotics applications with your Amiga."}),"\n",(0,r.jsx)(n.h3,{id:"frames-of-reference",children:"Frames of Reference"}),"\n",(0,r.jsxs)(n.p,{children:["In robotics, a ",(0,r.jsx)(n.strong,{children:"frame of reference"}),'\n(often called a "',(0,r.jsx)(n.strong,{children:"frame"}),'", ',(0,r.jsx)(n.strong,{children:"coordinate frame"}),', or "',(0,r.jsx)(n.strong,{children:"reference frame"}),'")\nis a description of a coordinate system of 3 orthogonal axes (',(0,r.jsx)(n.strong,{children:"x"}),", ",(0,r.jsx)(n.strong,{children:"y"}),", & ",(0,r.jsx)(n.strong,{children:"z"}),") defined by\nthe position and orientation of the object."]}),"\n",(0,r.jsx)(n.p,{children:"The two primary frames you need to be aware of are:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["World Frame (",(0,r.jsx)(n.code,{children:"world"}),")"]}),":\nConventionally, this is a fixed frame representing the environment in which the robot operates.\nThink of it as an anchor point that doesn't move.\nIf using RTK GPS, a typical world frame coordinate system is defined at the location\nof your RTK base station."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Robot Frame (",(0,r.jsx)(n.code,{children:"robot"}),")"]}),": This frame is attached to the robot.\nAs the robot moves, this frame moves with it.\nConsidering the robot is not a single point, it is important to define where on the robot\nis considered the center of the ",(0,r.jsx)(n.code,{children:"robot"})," frame axes.\nAt farm-ng we choose the center of the robot (in length & width) at ground level."]}),"\n",(0,r.jsxs)(n.p,{children:["Additional relevant frames for your Amiga-based robotics applications\nmay include the ",(0,r.jsx)(n.code,{children:"camera"})," frame, the ",(0,r.jsx)(n.code,{children:"imu"})," frame, the ",(0,r.jsx)(n.code,{children:"gps_antenna"})," frame, and so on."]}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.strong,{children:"reference frame"})," is represented below as a set of red-green-blue axes.\nThe frames are connected by 6 degree-of-freedom ",(0,r.jsx)(n.strong,{children:"transforms"}),",\nrepresented below by yellow arrows."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://github.com/farm-ng/amiga-dev-kit/assets/53625197/656fff08-0296-4d81-8990-dc65d7f1af16",alt:"image"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["Image Credit: ",(0,r.jsx)(n.a,{href:"https://foxglove.dev/blog/understanding-ros-transforms",children:"https://foxglove.dev/blog/understanding-ros-transforms"})]})}),"\n",(0,r.jsx)(n.h3,{id:"transformations",children:"Transformations"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"transformation"}),", or ",(0,r.jsx)(n.strong,{children:"transform"}),", describes how to move from one reference frame to another."]}),"\n",(0,r.jsxs)(n.p,{children:["Typically in robotics we represent these transforms as an ",(0,r.jsx)(n.strong,{children:"isometry"})," transformation in 3D space.\nThis is a distance-preserving 6 degree-of-freedom (DOF) transformation\nthat includes a translation (3 DOF) and a rotation (the other 3 DOF)."]}),"\n",(0,r.jsxs)(n.p,{children:["For instance, we can represent the transformation from the ",(0,r.jsx)(n.code,{children:"world"})," reference frame\nto the ",(0,r.jsx)(n.code,{children:"robot"})," reference frame.\nOur naming convention at farm-ng is to call this the ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"world_from_robot"})})," transformation,\nfollowing a ",(0,r.jsx)(n.code,{children:"<parent>_from_<child>"})," or ",(0,r.jsx)(n.code,{children:"<frame_a>_from_<frame_b>"})," naming convention."]}),"\n",(0,r.jsxs)(n.p,{children:["This transform contains the ",(0,r.jsx)(n.strong,{children:"translation"})," along the ",(0,r.jsx)(n.code,{children:"world"})," ",(0,r.jsx)(n.strong,{children:"x, y, z"})," axes,\nas well as the ",(0,r.jsx)(n.strong,{children:"rotation"})," required to align the axes."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"translation"}),", a 3-dimensional linear offset,\nis represented as a vector of ",(0,r.jsx)(n.code,{children:"[x, y, z]"})," coordinates in the parent reference frame."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"rotation"}),", a 3-dimensional rotation, can be represented in a number of ways,\nbut typically is represented as a ",(0,r.jsx)(n.strong,{children:"quaternion"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"quaternions",children:"Quaternions"}),"\n",(0,r.jsx)(n.p,{children:"Quaternions are a type of mathematical object used to represent rotations in 3D space."}),"\n",(0,r.jsxs)(n.p,{children:["Quaternions consist of four numbers ",(0,r.jsx)(n.code,{children:"(x, y, z, w)"})," (or sometimes in order ",(0,r.jsx)(n.code,{children:"(w, x, y, z)"}),").\n",(0,r.jsx)(n.code,{children:"w"})," represents the scalar (or real) part of the rotation\nand ",(0,r.jsx)(n.code,{children:"x"}),", ",(0,r.jsx)(n.code,{children:"y"}),", and ",(0,r.jsx)(n.code,{children:"z"})," are the vector (or imaginary) parts."]}),"\n",(0,r.jsx)(n.p,{children:"Quaternions are an alternative to other methods like Euler angles or rotation matrices.\nQuaternions are particularly useful because they are compact,\navoid certain problems like gimbal lock, and can be more computationally efficient."}),"\n",(0,r.jsx)(n.h4,{id:"transform-math",children:"Transform math"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Transforms"})," can be mathematically manipulated to understand where ",(0,r.jsx)(n.strong,{children:"coordinate frames"}),"\nare in relation to one another.\nMost commonly, you will ",(0,r.jsx)(n.strong,{children:"invert"})," transforms and you will ",(0,r.jsx)(n.strong,{children:"multiply"})," transforms."]}),"\n",(0,r.jsxs)(n.p,{children:["If you know the transform from the ",(0,r.jsx)(n.code,{children:"world"})," coordinate frame to the ",(0,r.jsx)(n.code,{children:"robot"})," coordinate frame (",(0,r.jsx)(n.code,{children:"world_from_robot"}),"),\nyou can ",(0,r.jsx)(n.strong,{children:"invert"})," that transform to get the transform from the ",(0,r.jsx)(n.code,{children:"robot"})," coordinate frame\nto the ",(0,r.jsx)(n.code,{children:"world"})," coordinate frame (",(0,r.jsx)(n.code,{children:"robot_from_world"}),")."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"world_from_robot = robot_from_imu^-1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you know two transforms with a common frame, you can ",(0,r.jsx)(n.strong,{children:"multiply"})," them."]}),"\n",(0,r.jsxs)(n.p,{children:["Say you know ",(0,r.jsx)(n.code,{children:"world_from_robot"})," and the ",(0,r.jsx)(n.code,{children:"robot_from_imu"})," transform from your\n",(0,r.jsx)(n.code,{children:"robot"})," frame to your ",(0,r.jsx)(n.code,{children:"imu"})," frame (where the IMU is on your robot).\nYou can calculate the transform from the ",(0,r.jsx)(n.code,{children:"world"})," frame to the ",(0,r.jsx)(n.code,{children:"imu"})," frame (",(0,r.jsx)(n.code,{children:"world_from_imu"}),")\nwith transform ",(0,r.jsx)(n.strong,{children:"multiplication"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"world_from_imu = world_from_robot * robot_from_imu\n"})}),"\n",(0,r.jsx)(n.h3,{id:"poses",children:"Poses"}),"\n",(0,r.jsxs)(n.p,{children:["We tend to think of where our robot is as a ",(0,r.jsx)(n.strong,{children:"pose"}),", a combination of ",(0,r.jsx)(n.strong,{children:"position"})," and ",(0,r.jsx)(n.strong,{children:"orientation"}),".\nThe ",(0,r.jsx)(n.strong,{children:"position"})," being where the robot is, and the ",(0,r.jsx)(n.strong,{children:"orientation"})," being which way the robot is facing."]}),"\n",(0,r.jsxs)(n.p,{children:["A pose is, however, undetermined as there needs to be a ",(0,r.jsx)(n.strong,{children:"frame of reference"})," the position\nand orientation are in.\nQueue ",(0,r.jsx)(n.strong,{children:"transforms"}),"!"]}),"\n",(0,r.jsxs)(n.p,{children:["We can define the ",(0,r.jsx)(n.strong,{children:"pose"})," of our robot as the 6-DOF transformation from the ",(0,r.jsx)(n.code,{children:"world"})," frame\nto our ",(0,r.jsx)(n.code,{children:"robot"})," frame (",(0,r.jsx)(n.code,{children:"world_from_robot"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["We are not limited to representing the ",(0,r.jsx)(n.code,{children:"world_from_robot"})," transformation as a pose.\nAny transform can be represented as a pose by correctly specifying the ",(0,r.jsx)(n.code,{children:"frame_a"})," (parent frame)\nand ",(0,r.jsx)(n.code,{children:"frame_b"})," (child frame) in our\n",(0,r.jsx)(n.a,{href:"https://github.com/farm-ng/farm-ng-core/blob/main/protos/farm_ng/core/pose.proto",children:(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"Pose"})," protobuf definition"]})}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"the-farm-ng-pose-proto",children:["The farm-ng ",(0,r.jsx)(n.code,{children:"Pose"})," proto"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["For the latest definition of the ",(0,r.jsx)(n.code,{children:"Pose"})," structure, please refer to our\n",(0,r.jsx)(n.a,{href:"https://github.com/farm-ng/farm-ng-core/blob/main/protos/farm_ng/core/pose.proto",children:(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"Pose"})," protobuf definition"]})}),"."]})}),"\n",(0,r.jsxs)(n.p,{children:["Each pose has an ",(0,r.jsx)(n.code,{children:"Isometry3F64"}),', which is a representation of rigid body transformations in 3D space.\nIn simple terms, it describes how an object moves and rotates in three-dimensional space\nwithout changing its shape.\nThe term "isometry" implies that distances between points remain unchanged during the transformation.']}),"\n",(0,r.jsxs)(n.p,{children:["In the context of robotics, ",(0,r.jsx)(n.code,{children:"Isometry3F64"})," is used to describe the movement\nand rotation of a robot in 3D space."]}),"\n",(0,r.jsx)(n.h4,{id:"properties-of-isometry3f64",children:"Properties of Isometry3F64"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Translation"}),": This represents the linear movement of the robot.\nThis is represented as a 3D vector, where each component (x, y, z) describes movement along that axis."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rotation"}),": This represents the angular movement of the robot.\nThis rotation is represented using ",(0,r.jsx)(n.code,{children:"Rotation3F64"}),", which, in this context, uses the Rz method\nto denote a rotation about the z-axis."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rz method"}),": The Rz method, when applied to Rotation3F64, denotes a rotation about the z-axis.\nIn 3D space, the z-axis typically points upwards, perpendicular to the ground plane\n(assuming the x-y plane represents the ground).\nWhen you rotate an object about the z-axis, it turns around this vertical line,\nmuch like how a spinning top rotates around its central axis."]}),"\n",(0,r.jsx)(n.h3,{id:"resources",children:"Resources"}),"\n",(0,r.jsx)(n.p,{children:"The use and multiplication of coordinate frame transforms is a fundamental concept in robotics!\nAs such, there is an abundance of quality, free resources on the topic."}),"\n",(0,r.jsxs)(n.p,{children:["For a slightly-less-brief introduction you can refer to ",(0,r.jsx)(n.a,{href:"https://foxglove.dev/blog/understanding-ros-transforms",children:"Understanding ROS Transforms"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If you wish to dive deeper on this topic, one option is ",(0,r.jsx)(n.a,{href:"https://ocw.mit.edu/courses/2-12-introduction-to-robotics-fall-2005/",children:"MIT OpenCourseWare - Introduction To Robotics"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>a});var r=o(96540);const s={},t=r.createContext(s);function i(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);