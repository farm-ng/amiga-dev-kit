"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6988],{5739:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=a(7462),i=(a(7294),a(3905));a(1839);const s={id:"canbus-stream",title:"03 - Canbus Stream"},r="Canbus Stream",o={unversionedId:"examples/virtual_joystick/canbus-stream",id:"examples/virtual_joystick/canbus-stream",title:"03 - Canbus Stream",description:"Add a canbus stream",source:"@site/docs/examples/virtual_joystick/03_canbus_stream.md",sourceDirName:"examples/virtual_joystick",slug:"/examples/virtual_joystick/canbus-stream",permalink:"/docs/examples/virtual_joystick/canbus-stream",draft:!1,editUrl:"https://github.com/farm-ng/amiga-dev-kit/tree/main/website/docs/examples/virtual_joystick/03_canbus_stream.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"canbus-stream",title:"03 - Canbus Stream"},sidebar:"examples",previous:{title:"02 - Template Overview",permalink:"/docs/examples/virtual_joystick/template-overview"},next:{title:"04 - Camera Stream",permalink:"/docs/examples/virtual_joystick/camera-stream"}},p={},l=[{value:"Add a canbus stream",id:"add-a-canbus-stream",level:3},{value:"imports",id:"imports",level:4},{value:"setup.cfg",id:"setupcfg",level:4},{value:"kivy Labels",id:"kivy-labels",level:4},{value:"Labels",id:"labels",level:4},{value:"CanbusClient",id:"canbusclient",level:4},{value:"stream_canbus",id:"stream_canbus",level:4},{value:"drawing",id:"drawing",level:4},{value:"command line args",id:"command-line-args",level:4},{value:"entry.sh",id:"entrysh",level:4},{value:"Run the app - canbus stream",id:"run-the-app---canbus-stream",level:3}],m={toc:l};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"canbus-stream"},"Canbus Stream"),(0,i.kt)("h3",{id:"add-a-canbus-stream"},"Add a canbus stream"),(0,i.kt)("p",null,"The first thing we'll add to our app is a canbus stream.\nThis will:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/py/farm_ng/canbus/canbus_client.py"},(0,i.kt)("strong",{parentName:"a"},(0,i.kt)("inlineCode",{parentName:"strong"},"CanbusClient")))),(0,i.kt)("li",{parentName:"ul"},"Parse ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/py/farm_ng/canbus/packet.py"},(0,i.kt)("strong",{parentName:"a"},(0,i.kt)("inlineCode",{parentName:"strong"},"AmigaTpdo1")))," (Amiga state) messages"),(0,i.kt)("li",{parentName:"ul"},"Draw values in realtime as kivy ",(0,i.kt)("a",{parentName:"li",href:"https://kivy.org/doc/stable/api-kivy.uix.label.html"},(0,i.kt)("strong",{parentName:"a"},(0,i.kt)("inlineCode",{parentName:"strong"},"Label")))," widgets")),(0,i.kt)("h4",{id:"imports"},"imports"),(0,i.kt)("p",null,"The imports we need to add for this step are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"from typing import Generator\nfrom typing import Optional\nimport grpc\n\nfrom farm_ng.canbus import canbus_pb2\nfrom farm_ng.canbus.canbus_client import CanbusClient\nfrom farm_ng.canbus.canbus_client import CanbusClientConfig\nfrom farm_ng.canbus.packet import AmigaControlState\nfrom farm_ng.canbus.packet import AmigaTpdo1\nfrom farm_ng.canbus.packet import parse_amiga_tpdo1_proto\n\n...\n\nfrom kivy.properties import StringProperty  # noqa: E402\n")),(0,i.kt)("admonition",{title:"Reminder",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Remember to place all kivy imports below the ",(0,i.kt)("inlineCode",{parentName:"p"},"Config.set(...)")," lines!")),(0,i.kt)("p",null,"Here we see the first imports from our ",(0,i.kt)("a",{parentName:"p",href:"#farm-ng-libraries"},(0,i.kt)("strong",{parentName:"a"},"farm-ng libraries")),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"farm_ng.canbus")," is defined in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga"},(0,i.kt)("strong",{parentName:"a"},"farm_ng_amiga"))," package."),(0,i.kt)("p",null,"The imports ending in ",(0,i.kt)("inlineCode",{parentName:"p"},"*_pb2")," are the compiled ",(0,i.kt)("inlineCode",{parentName:"p"},"*.proto")," definitions we use in the app.\nFor example, ",(0,i.kt)("inlineCode",{parentName:"p"},"from farm_ng.canbus import canbus_pb2")," imports the proto messages defined in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/protos/farm_ng/canbus/canbus.proto"},(0,i.kt)("strong",{parentName:"a"},"canbus.proto")),"."),(0,i.kt)("h4",{id:"setupcfg"},"setup.cfg"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"setup.cfg")," manages the dependencies we install for the app, and we'll need to add the following dependency under the ",(0,i.kt)("inlineCode",{parentName:"p"},"install_requires")," header:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"grpcio\n")),(0,i.kt)("p",null,"Now your ",(0,i.kt)("inlineCode",{parentName:"p"},"setup.cfg")," should look something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[metadata]\nname = Virtual_Joystick\n\n\n[options]\nsetup_requires =\n    wheel==0.37.1\ninstall_requires =\n    wheel==0.37.1\n    kivy= >=2.1.0\n    farm_ng_amiga\n    grpcio\npackage_dir =\n    = apps\npackages = find:\npython_requires = >=3.6\n\n[options.packages.find]\nwhere = apps\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"We may periodically update the ",(0,i.kt)("inlineCode",{parentName:"p"},"setup.cfg")," in the app template, so don't be surprised if yours doesn't match this exactly.\nJust drop ",(0,i.kt)("inlineCode",{parentName:"p"},"grpcio")," under ",(0,i.kt)("inlineCode",{parentName:"p"},"install_requires")," and you should be good to go!")),(0,i.kt)("h4",{id:"kivy-labels"},"kivy Labels"),(0,i.kt)("p",null,"Kivy has the concept of nesting, so not only can you add ",(0,i.kt)("inlineCode",{parentName:"p"},"Widgets")," within ",(0,i.kt)("inlineCode",{parentName:"p"},"Layouts"),", but also you can recursively add ",(0,i.kt)("inlineCode",{parentName:"p"},"Layouts")," within ",(0,i.kt)("inlineCode",{parentName:"p"},"Layouts"),".\nSince we have 3 parameters we want to view, we will add 3 ",(0,i.kt)("inlineCode",{parentName:"p"},"Label")," widgets in a ",(0,i.kt)("inlineCode",{parentName:"p"},"BoxLayout")," (which itself is in the base ",(0,i.kt)("inlineCode",{parentName:"p"},"RelativeLayout"),") to our kivy string, so that the kivy string is defined as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},'kv = """\nRelativeLayout:\n    Button:\n        id: back_btn_layout\n        pos_hint: {"x": 0.0, "top": 1.0}\n        background_color: 0, 0, 0, 0\n        size_hint: 0.1, 0.1\n        background_normal: "assets/back_button.png"\n        on_release: app.on_exit_btn()\n        Image:\n            source: "assets/back_button_normal.png" \\\n            if self.parent.state == "normal" \\\n            else "assets/back_button_down.png"\n            pos: self.parent.pos\n            size: self.parent.size\n    BoxLayout:\n        orientation: \'vertical\'\n        Label:\n            text: "state:\\\\n" + str(app.amiga_state)\n        Label:\n            text: "speed:\\\\n" + str(app.amiga_speed) + "  [m/s]"\n        Label:\n            text: "angular rate:\\\\n" + str(app.amiga_rate) + "  [rad/s]"\n"""\n')),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"BoxLayout")," stacks widgets horizontally by default, we define the orientation as ",(0,i.kt)("inlineCode",{parentName:"p"},"vertical"),", so the ",(0,i.kt)("inlineCode",{parentName:"p"},"Label")," widgets appear in a vertical column."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reference: ",(0,i.kt)("a",{parentName:"li",href:"https://kivy.org/doc/stable/api-kivy.uix.boxlayout.html"},(0,i.kt)("strong",{parentName:"a"},"Box Layout")))),(0,i.kt)("h4",{id:"labels"},"Labels"),(0,i.kt)("p",null,"We define 3 labels that are live updated with class variables from the ",(0,i.kt)("inlineCode",{parentName:"p"},"VirtualJoystickApp"),".\nIn order to update the value, e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},'Label:\n    text: "state:\\\\n" + str(app.amiga_state)\n')),(0,i.kt)("p",null,"the values must be declared as a ",(0,i.kt)("inlineCode",{parentName:"p"},"StringProperty")," of the class\nbefore the class is initialized and should be defined as type ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),"."),(0,i.kt)("p",null,"So our initializer (eventually) becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},'class VirtualJoystickApp(App):\n    # For kivy labels\n    amiga_speed = StringProperty()\n    amiga_rate = StringProperty()\n    amiga_state = StringProperty()\n\n    def __init__(self, address: str, canbus_port: int) -> None:\n        super().__init__()\n        self.address: int = address\n        self.canbus_port: int = canbus_port\n\n        # Received\n        self.amiga_tpdo1: AmigaTpdo1 = AmigaTpdo1()\n        self.amiga_state: str = "NO CANBUS\\nSERVICE DETECTED"\n        self.amiga_speed: str = "???"\n        self.amiga_rate: str = "???"\n\n        self.async_tasks: List[asyncio.Task] = []\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This initializer already includes the command line args and ",(0,i.kt)("inlineCode",{parentName:"p"},"AmigaTpdo1")," container we will add later.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reference: ",(0,i.kt)("a",{parentName:"li",href:"https://kivy.org/doc/stable/api-kivy.uix.label.html"},(0,i.kt)("strong",{parentName:"a"},"Label"))),(0,i.kt)("li",{parentName:"ul"},"Reference: ",(0,i.kt)("a",{parentName:"li",href:"https://kivy.org/doc/stable/api-kivy.properties.html#kivy.properties.StringProperty"},(0,i.kt)("strong",{parentName:"a"},"StringProperty")))),(0,i.kt)("h4",{id:"canbusclient"},"CanbusClient"),(0,i.kt)("p",null,"Next, we'll configure and create the gRPC client that will connect to the gRPC canbus service running in the background of the brain.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"CanbusClient")," is part of the farm-ng API, specifically ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga"},(0,i.kt)("strong",{parentName:"a"},"farm_ng_amiga")),"."),(0,i.kt)("p",null,"The clients define an API that allows you to interact with the services. See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/py/farm_ng/canbus/canbus_client.py"},(0,i.kt)("strong",{parentName:"a"},(0,i.kt)("inlineCode",{parentName:"strong"},"CanbusClient")))," for an example.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"CanbusClient")," is constructed with a ",(0,i.kt)("inlineCode",{parentName:"p"},"CanbusClientConfig"),", which itself is constructed with an ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"port"),".\nWe'll momentarily assume we have two parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"self.address")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"self.canbus_port")," to be used in this constructor, and add those next."),(0,i.kt)("p",null,"We'll also replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"template_function()")," placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"asyncio.Task")," with the tasks required for streaming the canbus."),(0,i.kt)("p",null,"So we add to our ",(0,i.kt)("inlineCode",{parentName:"p"},"app_func()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"# configure the canbus client\ncanbus_config: CanbusClientConfig = CanbusClientConfig(address=self.address, port=self.canbus_port)\ncanbus_client: CanbusClient = CanbusClient(canbus_config)\n\n# Canbus task(s)\nself.async_tasks.append(asyncio.ensure_future(self.stream_canbus(canbus_client)))\nself.async_tasks.append(asyncio.ensure_future(canbus_client.poll_service_state()))\n")),(0,i.kt)("p",null,"These tasks include the app specific function ",(0,i.kt)("inlineCode",{parentName:"p"},"stream_canbus")," we will define in app momentarily, as well as two generic the ",(0,i.kt)("inlineCode",{parentName:"p"},"poll_service_state()")," method required for all clients.\n",(0,i.kt)("inlineCode",{parentName:"p"},"poll_service_state()")," regularly checks the state of the gRPC service the client is connected to, and updates the ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," parameter of the client.\nThe service's ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," can then be checked wherever relevant in the app to ensure the services are running.\nIt's recommended to check this state every iteration in each asynchronous loop that relies on that service."),(0,i.kt)("h4",{id:"stream_canbus"},"stream_canbus"),(0,i.kt)("p",null,"Here we create a task that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"listens to the canbus client's stream"),(0,i.kt)("li",{parentName:"ul"},"filters for ",(0,i.kt)("inlineCode",{parentName:"li"},"AmigaTpdo1")," messages"),(0,i.kt)("li",{parentName:"ul"},"extracts useful values from ",(0,i.kt)("inlineCode",{parentName:"li"},"AmigaTpdo1")," messages")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},'async def stream_canbus(self, client: CanbusClient) -> None:\n    """This task:\n\n    - listens to the canbus client\'s stream\n    - filters for AmigaTpdo1 messages\n    - extracts useful values from AmigaTpdo1 messages\n    """\n    while self.root is None:\n        await asyncio.sleep(0.01)\n\n    response_stream: Optional[Generator[canbus_pb2.StreamCanbusReply]] = None\n\n    while True:\n        while client.state.value != canbus_pb2.CanbusServiceState.RUNNING:\n            await client.connect_to_service()\n\n        if response_stream is None:\n            response_stream = client.stub.streamCanbusMessages(canbus_pb2.StreamCanbusRequest())\n\n        response: canbus_pb2.StreamCanbusReply = await response_stream.read()\n        if response == grpc.aio.EOF:\n            # Checks for end of stream\n            break\n        if response and response.status == canbus_pb2.ReplyStatus.OK:\n            for proto in response.messages.messages:\n                amiga_tpdo1: Optional[AmigaTpdo1] = parse_amiga_tpdo1_proto(proto)\n                if amiga_tpdo1:\n                    self.amiga_tpdo1 = amiga_tpdo1\n\n        # Shorter sleep than typical 10ms since canbus is very high rate\n        await asyncio.sleep(0.001)\n')),(0,i.kt)("p",null,"With"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"response_stream: Optional[Generator[canbus_pb2.StreamCanbusReply]] = None\n")),(0,i.kt)("p",null,"we are being explicit the type of stream we will be connecting to / declaring the type ",(0,i.kt)("inlineCode",{parentName:"p"},"response_stream")," will contain (with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional")," decorator because it starts as ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," until we are ready to initialize it), but you may need a little more gRPC understanding to create this line."),(0,i.kt)("admonition",{title:"gRPC life cycle deep dive",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"As explained in the ",(0,i.kt)("a",{parentName:"p",href:"https://grpc.io/docs/what-is-grpc/core-concepts/#rpc-life-cycle"},(0,i.kt)("strong",{parentName:"a"},"gRPC core concepts - RPC life cycle"))," section, there are 4 types server methods."),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://grpc.io/docs/what-is-grpc/core-concepts/#unary-rpc"},(0,i.kt)("strong",{parentName:"a"},"Unary")),": single request -> single response"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://grpc.io/docs/what-is-grpc/core-concepts/#server-streaming-rpc"},(0,i.kt)("strong",{parentName:"a"},"Server streaming")),": single request -> stream of responses"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://grpc.io/docs/what-is-grpc/core-concepts/#client-streaming-rpc"},(0,i.kt)("strong",{parentName:"a"},"Client streaming")),": stream of requests -> single response"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc"},(0,i.kt)("strong",{parentName:"a"},"Bidirectional streaming")),": stream of requests -> stream of responses"))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Most")," of our services have a server streaming RPC set up, so the canbus client can send a single request to the canbus service and proceed to receive the stream of canbus messages until the stream is explicitly stopped, or either of the client or service is killed."),(0,i.kt)("p",null,"And in this case we will be receiving a server stream from the ",(0,i.kt)("inlineCode",{parentName:"p"},"canbus")," service of proto defined message ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamCanbusReply"),".\nThis is defined as the RPC ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/protos/farm_ng/canbus/canbus.proto"},(0,i.kt)("strong",{parentName:"a"},"streamCanbusMessages")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"while True:\n    while client.state.value != canbus_pb2.CanbusServiceState.RUNNING:\n        await client.connect_to_service()\n\n    if response_stream is None:\n        response_stream = client.stub.streamCanbusMessages(\n            canbus_pb2.StreamCanbusRequest()\n        )\n")),(0,i.kt)("p",null,"This pattern is relevant as the task starts.\nBasically, we get stuck in a loop until we see that the service is in state ",(0,i.kt)("inlineCode",{parentName:"p"},"RUNNING"),", which is accomplished by using the client defined method ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/py/farm_ng/canbus/canbus_client.py"},(0,i.kt)("strong",{parentName:"a"},(0,i.kt)("inlineCode",{parentName:"strong"},"connect_to_service()")))," (a method we implement in all of our clients)."),(0,i.kt)("p",null,"Once we are connected to the client, we initialize the stream of responses in our server streaming RPC with the ",(0,i.kt)("a",{parentName:"p",href:"https://grpc.io/docs/what-is-grpc/core-concepts/#using-the-api"},(0,i.kt)("strong",{parentName:"a"},"client ",(0,i.kt)("em",{parentName:"strong"},"stub"))),"."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Note that the names of the methods and protos match those defined in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/protos/farm_ng/canbus/canbus.proto"},(0,i.kt)("strong",{parentName:"a"},"canbus.proto")),". This is a requirement of gRPC.")),(0,i.kt)("p",null,"Now that our ",(0,i.kt)("inlineCode",{parentName:"p"},"CanbusClient")," is connected to the canbus service and the stream of ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamCanbusReply")," messages has been requested, the fun starts."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"response: canbus_pb2.StreamCanbusReply = await response_stream.read()\n")),(0,i.kt)("p",null,"Each iteration we stop at this line and wait for the next ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamCanbusReply")," response on the queue, using the async ",(0,i.kt)("inlineCode",{parentName:"p"},"await")," expression."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"if response == grpc.aio.EOF:\n    # Checks for end of stream\n    break\n")),(0,i.kt)("p",null,"With our fresh ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamCanbusReply")," in hand, we check if the message contains the end of the stream (not likely in our application since we stream until killed, but is still good practice) before proceeding."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"if response and response.status == canbus_pb2.ReplyStatus.OK:\n    for proto in response.messages.messages:\n        amiga_tpdo1: Optional[AmigaTpdo1] = parse_amiga_tpdo1_proto(proto)\n        if amiga_tpdo1:\n            self.amiga_tpdo1 = amiga_tpdo1\n\nawait asyncio.sleep(0.001)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamCanbusReply"),", defined in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/protos/farm_ng/canbus/canbus.proto"},(0,i.kt)("strong",{parentName:"a"},"canbus.proto")),", can contain repeated messages of format ",(0,i.kt)("inlineCode",{parentName:"p"},"RawCanbusMessage"),".\nSo we iterate through these, and for each message use the ",(0,i.kt)("inlineCode",{parentName:"p"},"parse_amiga_tpdo1_proto()")," utility to return an ",(0,i.kt)("inlineCode",{parentName:"p"},"AmigaTpdo1")," packet, both defined in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/py/farm_ng/canbus/packet.py"},(0,i.kt)("strong",{parentName:"a"},"farm_ng.canbus.packet")),", if the message matches the id and format we expect.\nSince the can bus operates as an all-to-all communication network, we have to filter out messages we aren't interested in and can't assume all messages are what we want."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This is the ",(0,i.kt)("inlineCode",{parentName:"p"},"AmigaTpdo1")," container we added in our initializer earlier.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"AmigaTpdo1")," message comes from the dashboard and contains the:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"state of the Amiga (AmigaControlState)"),(0,i.kt)("li",{parentName:"ul"},"measured speed (forward positive)"),(0,i.kt)("li",{parentName:"ul"},"measured angular rate (left positive)")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"This is the information you'll use for closed loop control!")),(0,i.kt)("p",null,"Finally we sleep for 1 ms before the next iteration of the ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," loop.\nTypically we sleep for 10 ms, as you'll see in ",(0,i.kt)("inlineCode",{parentName:"p"},"stream_camera")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reference: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/py/farm_ng/canbus/canbus_client.py"},(0,i.kt)("strong",{parentName:"a"},"farm_ng.canbus.canbus_client"))),(0,i.kt)("li",{parentName:"ul"},"Reference: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/py/farm_ng/canbus/packet.py"},(0,i.kt)("strong",{parentName:"a"},"farm_ng.canbus.packet"))),(0,i.kt)("li",{parentName:"ul"},"Reference: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/protos/farm_ng/canbus/canbus.proto"},(0,i.kt)("strong",{parentName:"a"},"canbus.proto")))),(0,i.kt)("h4",{id:"drawing"},"drawing"),(0,i.kt)("p",null,"We'll rename the placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"template_function()"),' and use it for drawing with kivy.\nFor now the only thing we need to "draw" is updating the values in the ',(0,i.kt)("inlineCode",{parentName:"p"},"StringProperty")," strings.\nSo let's define two functions."),(0,i.kt)("p",null,"We'll add a simple utility for updating the displayed strings in the kivy ",(0,i.kt)("inlineCode",{parentName:"p"},"Label")," widgets by parsing the values from the most recent ",(0,i.kt)("inlineCode",{parentName:"p"},"AmigaTpdo1")," message."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},'def update_kivy_strings(self) -> None:\n    """Updates the `StringProperty` strings displayed as `Label` widgets."""\n    self.amiga_state = AmigaControlState(self.amiga_tpdo1.state).name[6:]\n    self.amiga_speed = str(self.amiga_tpdo1.meas_speed)\n    self.amiga_rate = str(self.amiga_tpdo1.meas_ang_rate)\n')),(0,i.kt)("p",null,"And we'll add an ",(0,i.kt)("inlineCode",{parentName:"p"},"async")," function called ",(0,i.kt)("inlineCode",{parentName:"p"},"draw()")," (replacing ",(0,i.kt)("inlineCode",{parentName:"p"},"template_function()"),") for calling this in perpetuity."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"async def draw(self) -> None:\n    while self.root is None:\n        await asyncio.sleep(0.01)\n\n    while True:\n        self.update_kivy_strings()\n        await asyncio.sleep(0.01)\n\n")),(0,i.kt)("p",null,"Here we loop forever, constantly updating the ",(0,i.kt)("inlineCode",{parentName:"p"},"StringProperty")," strings displayed as ",(0,i.kt)("inlineCode",{parentName:"p"},"Label")," widgets, containing values from the most recent ",(0,i.kt)("inlineCode",{parentName:"p"},"AmigaTpdo1")," message with our simple ",(0,i.kt)("inlineCode",{parentName:"p"},"update_kivy_strings()")," method.\nEach loop we also sleep for our default duration of 10ms before the next iteration."),(0,i.kt)("p",null,"Remember to update the function name of the ",(0,i.kt)("inlineCode",{parentName:"p"},"asyncio.Task")," in our list in ",(0,i.kt)("inlineCode",{parentName:"p"},"app_func()")," to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},"# Drawing task(s)\nself.async_tasks.append(asyncio.ensure_future(self.draw()))\n")),(0,i.kt)("h4",{id:"command-line-args"},"command line args"),(0,i.kt)("p",null,"Finally, we add the two arguments required by the ",(0,i.kt)("inlineCode",{parentName:"p"},"CanbusClientConfig"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Python"},'if __name__ == "__main__":\n    parser = argparse.ArgumentParser(prog="virtual-joystick")\n\n    parser.add_argument("--address", type=str, default="localhost", help="The server address")\n    parser.add_argument(\n        "--canbus-port", type=int, required=True, help="The grpc port where the canbus service is running."\n    )\n    args = parser.parse_args()\n\n    loop = asyncio.get_event_loop()\n    try:\n        loop.run_until_complete(VirtualJoystickApp(args.address, args.canbus_port).app_func())\n    except asyncio.CancelledError:\n        pass\n    loop.close()\n')),(0,i.kt)("p",null,"These are values used by gRPC to link client to server and are handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"entry.sh"),"."),(0,i.kt)("h4",{id:"entrysh"},"entry.sh"),(0,i.kt)("admonition",{title:"coming soon",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Instructions for editing entry.sh to automatically use these args")),(0,i.kt)("p",null,"For now, just hard code the values in ",(0,i.kt)("inlineCode",{parentName:"p"},"entry.sh")," to match the ",(0,i.kt)("inlineCode",{parentName:"p"},"launcher_configuration.json"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"entry.sh")," should become:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#!/bin/bash -ex\nDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"\n\n$DIR/bootstrap.sh $DIR $DIR/venv\n\n$DIR/venv/bin/python $DIR/main.py --canbus-port 50060\n\nexit 0\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you change the canbus port in the ",(0,i.kt)("inlineCode",{parentName:"p"},"launcher_configuration.json"),", hard code the corresponding value.")),(0,i.kt)("h3",{id:"run-the-app---canbus-stream"},"Run the app - canbus stream"),(0,i.kt)("p",null,"Now sync the app to the Brain and launch it with the following instructions!"),(0,i.kt)("admonition",{title:"Deploy Instructions",type:"info"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{parentName:"p",href:"/docs/brain/brain-apps"},(0,i.kt)("strong",{parentName:"a"},"Deploy Instructions"))," for syncing the app onto the Amiga Brain.")),(0,i.kt)("p",null,"You should see the ",(0,i.kt)("inlineCode",{parentName:"p"},"AmigaTpdo1")," values update in realtime as you drive the amiga and change between various command states. See ",(0,i.kt)("a",{parentName:"p",href:"/docs/dashboard/control-states"},(0,i.kt)("strong",{parentName:"a"},"Amiga Control States"))," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/farm-ng/farm-ng-amiga/blob/main/py/farm_ng/canbus/packet.py"},(0,i.kt)("strong",{parentName:"a"},(0,i.kt)("inlineCode",{parentName:"strong"},"AmigaControlState")))," for more information on the ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," parameter."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Make sure all your cables are disconnected from the Amiga before driving around!")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/53625197/200458674-f596c306-f10d-48f0-b336-c69dcb774811.png",alt:"canbus_stream"})),(0,i.kt)("admonition",{title:"Coming soon",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Link to this checkpoint")))}c.isMDXComponent=!0}}]);